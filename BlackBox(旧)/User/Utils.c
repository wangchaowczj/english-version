#include "includes.h"


//==================================================================================================
//| 函数名称 | U32DataCMP 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 比较指定缓冲区中的数据(32位数据),返回最大相差值
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ptr:需要比较的数据缓冲区首址
//|          | length:需要比较的数据缓冲区长度
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 缓冲区中数据最大相差值
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：ZH    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u32 U32DataCMP(const u32* ptr, u8 length)
{
	u32 max_value, min_value ;
	u8 i ;

	max_value = *ptr; //最大值
	min_value = *ptr; //最小值
	for(i=1;i<length;i++)
	{
		if(*(ptr+i)>max_value)
		{
			max_value = *(ptr+i) ;
		}
		else if(*(ptr+i) < min_value)
		{
			min_value = *(ptr+i) ;
		}
	}
	return (max_value - min_value);	//返回相差值
}

//==================================================================================================
//| 函数名称 | U16DataCMP 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 比较指定缓冲区中的数据(16位数据),返回最大相差值
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ptr:需要比较的数据缓冲区首址
//|          | length:需要比较的数据缓冲区长度
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 缓冲区中数据最大相差值
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：ZH    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u16 U16DataCMP(const u16* ptr, u8 length)
{
	u16 max_value, min_value ;
	u8 i ;

	max_value = *ptr; //最大值
	min_value = *ptr; //最小值
	for(i=1;i<length;i++)
	{
		if(*(ptr+i)>max_value)
		{
			max_value = *(ptr+i) ;
		}
		else if(*(ptr+i) < min_value)
		{
			min_value = *(ptr+i) ;
		}
	}
	return (max_value - min_value);	//返回相差值
}

//==================================================================================================
//| 函数名称 | GetU16DataMax 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 对一组数据(16位)求最大值
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ptr 指针，指要求平均值的数据
//|          | lenght数据个数
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 最大值
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：ZH    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u16 GetU16DataMax(const u16* ptr, u8 length)
{
	u16 max_value =0;
	u8 i ;

	max_value = *ptr; //最大值
	for(i=1;i<length;i++)
	{
		if(*(ptr+i)>max_value)
		{
			max_value = *(ptr+i) ;
		}
	}
	return max_value ;	//返回最大值
}

//==================================================================================================
//| 函数名称 | GetU16DataMin 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 对一组数据(16位)求最小值
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ptr 指针，指要求平均值的数据
//|          | lenght数据个数
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 最小值
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：ZH    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u16 GetU16DataMin(const u16* ptr, u8 length)
{
	u16 min_value = 0 ;
	u8 i ;

	min_value = *ptr; //最小值
	for(i=1;i<length;i++)
	{
		if(*(ptr+i) < min_value)
		{
			min_value = *(ptr+i) ;
		}
	}
	return min_value ;	//返回最小值
}

//==================================================================================================
//| 函数名称 | GetU16DataAverage 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 对数据(16位)求平均值
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ptr 指针，指要求平均值的数据
//|          | lenght数据个数
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 平均值
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：ZH    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u16 GetU16DataAverage(u16* ptr, u16 lenght)
{
	u16 i;
	u32 sum = 0;
	
	for(i=0; i< lenght; i++)
	{
		sum += *ptr++;
	}
	if(lenght!=0)
	{
		sum /= lenght ;
	}

	return (u16)sum;
}

//==================================================================================================
//| 函数名称 | U16DataFallRank 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 把数据(16位)从大到小按顺序排列
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | ptr_s 指针，指向排列前的数据
//|          | ptr_d 指针，指向排序后的数据
//|          | lenght要排序的数据个数
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：ZH    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void U16DataFallRank(u16* ptr_s, u16* ptr_d, u16 lenght)
{
	u16 i,j,temp;
	u8 flag_bit;
	
	if(lenght == 0)
	{
		return ;
	}
	memcpy((u8*)ptr_d, (u8*)ptr_s, lenght*2);
	for(i=0; i < lenght-1; i++)
	{
		flag_bit = 1;
		for(j=0; j < lenght-i-1; j++)
		{
			 if(*(ptr_d+j)<*(ptr_d+j+1))
			 {
				 flag_bit = 0 ;
				 temp = *(ptr_d+j) ;
				 *(ptr_d+j) = *(ptr_d+j+1);
				 *(ptr_d+j+1)= temp ;
			 }
		}
		if(flag_bit)//提前结束排序
		{
			break ;
		}		
	}
}
/*
#define XA3_CHECK_IN                  0x42              // 点名
#define XA3_CLEAR_ALL                 0x0A              // 全局软复位
#define XA3_RESET_ALL                 0x1A              // 全局硬件复位
#define XA3_EN_CHARGE_ALL             0xE2              // 全局充电允许
#define XA3_EXPEN_ALL                 0xFA              // 全局准备起爆
#define XA3_SERLRD                    0x12              // 数据回读
#define XA3_WR_EEPROM                 0x22              // 数据编程
#define XA3_RD_PWD                    0xB2              // 密码读取
#define XA3_MASK                      0x32              // 屏蔽指令
#define XA3_PWD_UNLOCK                0xAA              // 解密指令
#define XA3_WR_FIX_DELAY_UNLOCK       0xDA              // 写固定延期解锁
#define XA3_WR_EE_DATA_UNLOCK         0xCA              // 写数据解锁解锁
#define XA3_WR_FIX_DELAY              0xC2              // 写固定延期时间编程
#define XA3_RESET                     0x3A              // 单个硬件复位
#define XA3_CHECKOSC_ALL              0x2A              // 全局时钟校准
#define XA3_WR_TIME                   0x4A              // 设置延期时间
#define XA3_RD_TIME                   0x52              // 延期时间回读
#define XA3_RD_STATUS                 0x7A              // 状态回读
#define XA3_BIT                       0x5A              // BIT测试
#define XA3_CHARGE                    0x6A              // 充电
#define XA3_CHARGE_ALL                0xEA              // 全局充电

*/
ErrorStatus GetDetCmdNameString(u8 Cmd, char* Ptr)
{
    ErrorStatus Result = SUCCESS;
    
    switch(Cmd)
    {
        case 0x42:
            strcpy(Ptr, "查漏");
            break;
        case 0x0A:
            strcpy(Ptr, "全局软复位");
            break;
        case 0x1A:
            strcpy(Ptr, "全局硬件复位");
            break;
        case 0xE2:
            strcpy(Ptr, "全局充电允许");
            break;
        case 0xFA:
            strcpy(Ptr, "全局准备起爆");
            break;
        case 0x12:
            strcpy(Ptr, "序列码回读");
            break;
        case 0x22:
            strcpy(Ptr, "数据编程");
            break;
        case 0xB2:
            strcpy(Ptr, "密码读取");
            break;
        case 0x32:
            strcpy(Ptr, "屏蔽指令");
            break;
        case 0xAA:
            strcpy(Ptr, "解密指令");
            break;
        case 0xDA:
            strcpy(Ptr, "写固定延期解锁");
            break;
        case 0xCA:
            strcpy(Ptr, "写数据解锁解锁");
            break;
        case 0xC2:
            strcpy(Ptr, "写固定延期时间编程");
            break;
        case 0x3A:
            strcpy(Ptr, "单个硬件复位");
            break;
        case 0x2A:
            strcpy(Ptr, "全局时钟校准");
            break;
        case 0x4A:
            strcpy(Ptr, "设置延期时间");
            break;
        case 0x52:
            strcpy(Ptr, "延期时间回读");
            break;
        case 0x7A:
            strcpy(Ptr, "状态回读");
            break;
        case 0x5A:
            strcpy(Ptr, "BIT测试");
            break;
        case 0x6A:
            strcpy(Ptr, "充电");
            break;
        case 0xEA:
            strcpy(Ptr, "全局充电");
            break;
        default:
            Result = ERROR;
            break;            
    }
    return Result;
}

