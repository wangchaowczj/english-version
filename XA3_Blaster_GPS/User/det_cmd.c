#include "includes.h"


//==================================================================================================
//| 函数名称 | EB_DetClrAll 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 全局复位指令，对所有雷管发送复位信号
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void EB_DetClrAll(void)
{
    u8 cmd[] = {CLRALL/* 全局复位 */, 0x00, 0x00};
	
	OSSchedLock();//发送命令期间禁止切换任务,避免其他任务扶起当前任务
	
	/* 发送 */
	DetTransmit(cmd, sizeof(cmd));
	
	OPEN_DET_RECEIVE_RES();//设置为接收状态
	ADJUST_G_RESET();//让比较器复位一下
	SET_LV_6_7V(); //切换到正常状态	
	OSSchedUnlock();//打开任务切换
} 

//==================================================================================================
//| 函数名称 | EB_DetMask 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 屏蔽雷管指令
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-需要进行bit检测的雷管序列码首址
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetMask(const u8 *psn)
{
    u8 cmd[3] = {MASK/* bit检测 */, 0x00, 0x00};
	u8 buf[1] = {0x00};	// 用于缓存同步头，实际没有数据

	cmd[1] = *psn;
	cmd[2] = *(psn + 1);
	
	OSSchedLock();//发送命令期间禁止切换任务,避免其他任务扶起当前任务
	
	/* 发送 */
	DetTransmit(cmd, sizeof(cmd));

	/* 只接收同步头 */
	if(DetReceiver(buf, 0) == EB_DET_TRANSCEIVER_SUCCESS)
	{
		OSSchedUnlock();//打开任务切换
		return DET_CMD_SUCCESS;    //指令执行成功
	}
	OSSchedUnlock();//打开任务切换
	return DET_CMD_FAIL;               //指令执行失败
}

//==================================================================================================
//| 函数名称 | EB_DetMaskTry 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 屏蔽雷管指令
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-需要进行bit检测的雷管序列码首址
//|          | retry-重试次数
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetMaskTry(const u8 *psn, u8 retry)
{
    u8 result = DET_CMD_FAIL;
	
    while(retry--)
	{
	    result = EB_DetMask(psn/*序列号*/);
		if(result == DET_CMD_SUCCESS)
		{// bit1指令执行成功
		    return result;
		}
	}

	return result;
} /* EB_DetMaskTry */

//==================================================================================================
//| 函数名称 | EB_DetCheckIn 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 查漏指令，检测雷管是否在线
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetCheckIn(void)
{
    u8 cmd[3] = {CHECK_IN/* 查漏指令 */, 0x00, 0x00};
	u8 buf[1] = {0x00};	// 用于缓存同步头，实际没有数据

	OSSchedLock();//发送命令期间禁止切换任务,避免其他任务扶起当前任务
	
	/* 发送 */
	DetTransmit(cmd, sizeof(cmd)) ;

	/* 只接收同步头 */
	if(DetReceiver(buf, 0) == EB_DET_TRANSCEIVER_SUCCESS)
	{
		OSSchedUnlock();//打开任务切换
		return DET_CMD_SUCCESS;    //指令执行成功
	}
	OSSchedUnlock();//打开任务切换
	return DET_CMD_FAIL;               //指令执行失败
} /* EB_DetCheckIn */

//==================================================================================================
//| 函数名称 | EB_DetSerlRD 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 读取雷管序列码
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | buf-雷管返回数据缓冲区
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetSerlRD(u8 *buf)
{
    unsigned char cmd[3] = {SERLRD/* 读序列码指令 */, 0x00, 0x00};

	OSSchedLock();//发送命令期间禁止切换任务,避免其他任务扶起当前任务
	
	/* 发送 */
	DetTransmit(cmd, sizeof(cmd));

	/* 不测频，接收6个字节数据 */
	if(DetReceiver(buf, 0x06) == EB_DET_TRANSCEIVER_SUCCESS)
	{
		OSSchedUnlock();//打开任务切换
		return DET_CMD_SUCCESS;    //指令执行成功
	}
	OSSchedUnlock();//打开任务切换
	return DET_CMD_FAIL;               //指令执行失败
} /* EB_DetSerlRD */

//==================================================================================================
//| 函数名称 | EB_DetSerlRDTry 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 读取雷管序列码, 并重试指定的次数 
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | buf：雷管返回数据缓冲区首址
//|          | retry：重试次数，不小于3
//|----------|--------------------------------------------------------------------------------------        
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | retry小于3时，修改为3
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetSerlRDTry(u8 *buf, u8 retry)
{
    const u8 buffer_size = 5;
	u8 temp[buffer_size][6];      // 缓存读到的雷管数据
	const u8 comm_fail[] = {0xFF/*0*/, 0xFF/*1*/, 0xFF/*2*/, 0xFF/*3*/, 0xFF/*4*/, 0xFF/*5*/};  // 通信失败temp中存储的值
	u8 count = 0;	   // 记录正确接收到的雷管数据数据
	u8 i,j;            // 用于数据比较
	u8 result = 0;     // 记录雷管指令返回结果
	u8 rtn = 0;        // 记录比较指令返回结果
	u8 same_count = 1; // 用于比较当前存在相同数据的次数

	memset(temp, 0xFF, sizeof(temp));
	if(retry<3)
	{
		retry = 3;	
	}
	while(retry--)
	{
	    result = EB_DetSerlRD(&temp[count][0]);	/* 接收数据处理函数对同步头已有验证，通信正常，同步头就符合要求，
		                                             * 频率根据同步头计算，因此也认为频率是正确的
		                                             */
		if(result == DET_CMD_SUCCESS)
		{// 数据接收成功
			count++;
			if(count>2)
			{
			    for(i = 0; i < (count-2); i++)
				{
					rtn = memcmp(&temp[i][0], comm_fail, 6/*芯片信息长度*/); // 如果芯片信息长度不全是0xFF，则认为接收到数据有效
					if(rtn!=0)
					{// 数据接收正常
						same_count = 1;//当前存在相同数据的次数
						for(j = (i+1); j < count; j++)
						{
			                rtn = memcmp(&temp[i][0], &temp[j][0], 6/*芯片信息长度*/); // 验证芯片信息长度是否一样
							if(rtn == 0)
							{// 数据一样
							    same_count++ ;
								if(same_count>=3)//当前至少有3次读取到的数据相同
								{
								    memcpy(buf, &temp[i][0], 6/*6(序列码长度)*/);
									return DET_CMD_SUCCESS;	// 序列码回读成功
								}
							}							
						}	
					}				
				}			
			}

			if(count == buffer_size) 
			{
				break;   // 缓冲区接收满
			}
		}

	} /* while(retry--) */
	
	return DET_CMD_FAIL; // 序列码回读失败
} /* EB_DetSerlRDTry */

//==================================================================================================
//| 函数名称 | EB_DetBit1 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 雷管桥头检测指令
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-需要进行bit检测的雷管序列码首址
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetBit1(const u8 *psn)
{
    u8 cmd[3] = {BIT1/* bit检测 */, 0x00, 0x00};
	u8 buf[1] = {0x00};	// 用于缓存同步头，实际没有数据

	OSSchedLock();//发送命令期间禁止切换任务,避免其他任务扶起当前任务
	
	cmd[1] = *psn;
	cmd[2] = *(psn + 1);
	/* 发送 */
	DetTransmit(cmd, sizeof(cmd));

	/* 只接收同步头 */
	if(DetReceiver(buf, 0) == EB_DET_TRANSCEIVER_SUCCESS)
	{
		OSSchedUnlock();//打开任务切换
		return DET_CMD_SUCCESS;    //指令执行成功
	}
	OSSchedUnlock();//打开任务切换
	return DET_CMD_FAIL;               //指令执行失败
} /* EB_det_Bit1 */

//==================================================================================================
//| 函数名称 | EB_DetBit1Try 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 雷管桥头检测指令,带重试次数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-需要进行bit检测的雷管序列码首址
//|          | retry-重试次数
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------        
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetBit1Try(const u8 *psn, u8 retry)
{
    u8 result = DET_CMD_FAIL;
	
    while(retry--)
	{
	    result = EB_DetBit1(psn/*序列号*/);
		if(result == DET_CMD_SUCCESS)
		{// bit1指令执行成功
		    return result;
		}
	}

	return result;
} /* EB_DetBit1Try */

//==================================================================================================
//| 函数名称 | EB_DetTimeRD 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 延时回读指令
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-雷管序列码首址
//|          | buf-雷管返回数据缓冲区
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------         
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetTimeRD(const u8 *psn, u8 *buf)
{
    u8 cmd[3] = {TIMERD/* 延时回读 */, 0x00, 0x00};

	OSSchedLock();//发送命令期间禁止切换任务,避免其他任务扶起当前任务
	
	cmd[1] = *psn;
	cmd[2] = *(psn + 1);
	/* 发送 */
	DetTransmit(cmd, sizeof(cmd));

	/* 接收4个字节雷管返回的数据 */
	if(DetReceiver(buf, 0x04) == EB_DET_TRANSCEIVER_SUCCESS)
	{
		OSSchedUnlock();//打开任务切换
		return DET_CMD_SUCCESS;    //指令执行成功
	}
	OSSchedUnlock();//打开任务切换
	return DET_CMD_FAIL;               //指令执行失败
} /* EB_det_TimeRD */

//==================================================================================================
//| 函数名称 | EB_DetTimeRDTry 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 延时回读, 并重试指定的次数 
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn:；雷管序列码首址
//|          | buf：雷管返回数据缓冲区首址
//|          | retry：重试次数，不小于3，否则得不到正确的结果
//|          | Delay：两条命令之间的延期间隔，MS为单位
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------         
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetTimeRDTry(const u8 *psn, u8 *buf, u8 retry, u16 Delay)
{
    const u8 buffer_size = 5;
	u8 temp[buffer_size][4];      // 缓存读到的雷管数据
	const u8 comm_fail[] = {0xFF/*0*/, 0xFF/*1*/, 0xFF/*2*/, 0xFF/*3*/, 0xFF/*4*/, 0xFF/*5*/};  // 通信失败temp中存储的值
	u8 count = 0;	   // 记录接收到的雷管数据数据
	u8 i,j;               // 用于数据比较
	u8 result = 0;      // 记录雷管指令返回结果
	int rtn = 0;        // 记录比较指令返回结果
	u8 same_count = 1; // 用于比较当前存在相同数据的次数	

	memset(temp, 0xFF, sizeof(temp));

	if(retry<3)
	{
		retry = 3;
	}
	while(retry--)
	{
		OSTimeDly(Delay);		

		result = EB_DetTimeRD(psn, &temp[count][0]);	/* 接收数据处理函数对同步头已有验证，通信正常，同步头就符合要求，
														 * 频率根据同步头计算，因此也认为频率是正确的
														 */
		if(result == DET_CMD_SUCCESS)
		{// 数据接收成功
			count++ ;
			if(count>2)
			{				
				for(i = 0; i < (count-2); i++)
				{
					rtn = memcmp(&temp[i][0], comm_fail, 4/*延时回读返回数据长度*/); // 如果返回数据不全是0xFF，则认为接收到数据有效		    
					if(rtn!=0)
					{// 数据接收正常
						same_count = 1;
						for(j = (i+1); j < count; j++)
						{
							rtn = memcmp(&temp[i][0], &temp[j][0], 4/*延时回读返回数据长度*/); // 验证返回数据是否一样
							if(rtn == 0)
							{// 数据一样
								same_count++ ;
								if(same_count>=3)
								{
									memcpy(buf, &temp[i][0], 4/*延时回读返回数据长度*/);
									return DET_CMD_SUCCESS;	// 序列码回读成功
								}
							}
						}
					} 					
				}
			}

			if(buffer_size == count) 
			{
				break;   // 缓冲区接收满
			}
		}
	} /* while(retry--) */
	return DET_CMD_FAIL; // 序列码回读失败
} /* EB_DetTimeRDTry */

//==================================================================================================
//| 函数名称 | EB_DetTimeRDTryErrorTry 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 延时回读, 并重试指定的次数及错误后可再重试
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn:；雷管序列码首址
//|          | buf：雷管返回数据缓冲区首址
//|          | retry：重试次数，不小于3，否则得不到正确的结果
//|          | Delay：两条命令之间的延期间隔，MS为单位
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------         
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetTimeRDTryErrorTry(const u8 *psn, u8 *buf, u8 retry, u8 ErrorRetryFlag)
{
	u8 Result ;
	
	Result = EB_DetTimeRDTry(psn, buf, retry, 0);
	if ((DET_CMD_FAIL == Result) && (ErrorRetryFlag != 0))
	{//错误后再重试
		Result = EB_DetTimeRDTry(psn, buf, retry, 500);
		OSTimeDlyHMSM(0,0,0,100);
	}
	return Result;
}
//==================================================================================================
//| 函数名称 | EB_DetTimeWR 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 写延期指令 
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-雷管序列码首址
//|          | scode-雷管密码
//|          | delay-写入雷管的延时时间
//|          | freq-雷管频率，单位HZ
//|          | bit4clk-64个雷管CLK对应的定时器计数值
//|          | det_dly_clk-写入雷管的延期时间对应的定时计数值
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------           
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetTimeWR(const u8 *psn, u8 scode, u16 delay, u32 freq, u32* det_dly_clk)
{
    u8 cmd[8] = {TIMEWR/* 写延期指令 */, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	u8 buf[1] = {0x00};	// 用于缓存同步头，实际没有数据
	u32 dly_clk = 0;

	dly_clk = (u32)((uint64_t)(delay+ALL_DET_DELAY) * (uint64_t)freq / 1000 + 1); //根据延期及频率计算时钟

	*det_dly_clk = dly_clk;

	cmd[1] = *psn;
	cmd[2] = *(psn + 1);
	cmd[3] = scode;
	cmd[4] = cmd[0];
	cmd[5] = (u8)dly_clk;
	cmd[6] = (u8)(dly_clk>>8);
	cmd[7] = (u8)(dly_clk>>16);
	
	OSSchedLock();//发送命令期间禁止切换任务,避免其他任务扶起当前任务
	
	/* 发送 */
	DetTransmit(cmd, sizeof(cmd));

	/* 只接收同步头 */
	if(DetReceiver(buf, 0) == EB_DET_TRANSCEIVER_SUCCESS)
	{
		OSSchedUnlock();//打开任务切换
		return DET_CMD_SUCCESS;    //指令执行成功
	} 
	OSSchedUnlock();//打开任务切换
	return DET_CMD_FAIL;               //指令执行失败
} /* EB_DetTimeWR */

//==================================================================================================
//| 函数名称 | EB_DetTimeWRTry 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 写延期指令 
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-雷管序列码首址
//|          | scode-雷管密码
//|          | delay-写入雷管的延时时间
//|          | freq-雷管频率，单位0.1KHZ
//|          | bit4clk-64个雷管CLK对应的定时器计数值
//|          | det_dly_clk-写入雷管的延期时间对应的定时计数值
//|          | retry-重试次数
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------             
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetTimeWRTry(const u8 *psn, u8 scode, u16 delay, u32 freq, u32* det_dly_clk, u8 retry)
{
    u8 result = DET_CMD_FAIL;
	
    while(retry--)
	{
	    result = EB_DetTimeWR(psn/*序列号*/, scode/*密码*/, delay/*延期值*/, freq/*频率值*/, det_dly_clk);
		if(result == DET_CMD_SUCCESS)
		{// 写延期指令执行成功
		    return result;
		}
	}

	return result;
} /* EB_DetTimeWRTry */

//==================================================================================================
//| 函数名称 | EB_DetCheckFreq 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 测频
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-雷管序列码首址
//|          | scode-雷管密码
//|          | buf-频率(HZ为单位)
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------             
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetCheckFreq(const u8 *psn, u8 scode, u32* freq)
{
    u8 cmd[8] = {TIMEWR/* 写延期指令 */, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    const u8 buffer_size = 3;
	u8 retry = 3;
	u32 temp[buffer_size];      // 缓存读到的频率
	u8 count = 0;	   // 记录接收到的雷管数据数据
	u8 buf[10];
	
	cmd[0] = TIMEWR;
	cmd[1] = *psn;
	cmd[2] = *(psn + 1);
	cmd[3] = scode;
	cmd[4] = cmd[0];
	cmd[5] = 0x0F;
	cmd[6] = 0x0F;
	cmd[7] = 0x0F;
	
	OSSchedLock();//发送命令期间禁止切换任务,避免其他任务扶起当前任务
		
	while(retry--)
	{
		/* 发送 */
		DetTransmit(cmd, sizeof(cmd));

		/* 只接收同步头 */
		if(DetReceiver(buf, 0) == EB_DET_TRANSCEIVER_SUCCESS)
		{
			cmd[0] = TIMERD;/* 延时回读 */
			cmd[1] = *psn;
			cmd[2] = *(psn + 1);
			retry = 6;
			while(retry--)
			{
				/* 发送 */
				DetTransmit(cmd, 3);

				/* 测频，需要接收4个字节雷管返回的数据， */
				if(DetReceiver((u8*)&temp[count], 0x84) == EB_DET_TRANSCEIVER_SUCCESS)
				{
					count++;
					if(count == buffer_size)
					{						
						if(U32DataCMP(temp, buffer_size) <= 500)//判断频率相差是否大于0.5K
						{
							*freq = (temp[0] + temp[1] + temp[2])/buffer_size;		
							OSSchedUnlock();//打开任务切换
							return DET_CMD_SUCCESS;    //指令执行成功
						}
						count = 0;//频率相差太多，重新测一次
					}
				}	
			} /*while(retry--)*/
			OSSchedUnlock();//打开任务切换
			return DET_CMD_FAIL;               //指令执行失败
		} 
	}
	OSSchedUnlock();//打开任务切换
	return DET_TIMERWR_FAIL;               //写延时错误
} /* EB_DetCheckFreq */

//==================================================================================================
//| 函数名称 | EB_DetCharge 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 充电指令 
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-雷管序列码首址
//|          | scode-雷管密码
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------             
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
//u8 EB_DetCharge(const u8 *psn, u8 scode)
//{
//    u8 cmd[5] = {CHARGE/* 充电指令 */, 0x00, 0x00, 0x00, 0x00};
//	u8 buf[1] = {0x00};	// 用于缓存同步头，实际没有数据
//	
//	cmd[1] = *psn;
//	cmd[2] = *(psn + 1);
//	cmd[3] = scode;
//	cmd[4] = cmd[1];
//	/* 发送 */
//	DetTransmit(cmd, sizeof(cmd));

//	/* 只接收同步头 */
//	if(DetReceiver(buf, 0) == EB_DET_TRANSCEIVER_SUCCESS)
//	{
//		return DET_CMD_SUCCESS;    //指令执行成功
//	}

//	return DET_CMD_FAIL;               //指令执行失败
//} /* EB_DetCharge */

//==================================================================================================
//| 函数名称 | EB_DetCharge 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 充电指令 
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-雷管序列码首址
//|          | scode-雷管密码
//|          | cmd_charge-充电指令代码
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------             
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetCharge(const u8 *psn, u8 scode, u8 cmd_charge)
{
    u8 cmd[5] = {0x00, 0x00, 0x00, 0x00, 0x00};
	u8 buf[1] = {0x00};	// 用于缓存同步头，实际没有数据
	
	cmd[0] = cmd_charge;
	cmd[1] = *psn;
	cmd[2] = *(psn + 1);
	cmd[3] = scode;
	cmd[4] = cmd[1];
	
	OSSchedLock();//发送命令期间禁止切换任务,避免其他任务扶起当前任务
		
	/* 发送 */
	DetTransmit(cmd, sizeof(cmd));

	/* 只接收同步头 */
	if(DetReceiver(buf, 0) == EB_DET_TRANSCEIVER_SUCCESS)
	{
		OSSchedUnlock();//打开任务切换
		return DET_CMD_SUCCESS;    //指令执行成功
	}
	OSSchedUnlock();//打开任务切换
	return DET_CMD_FAIL;               //指令执行失败
} /* EB_DetCharge */

//==================================================================================================
//| 函数名称 | EB_DetChargeTry 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 充电指令,带重试次数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-雷管序列码首址
//|          | scode-雷管密码
//|          | retry-重试次数
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------             
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
//u8 EB_DetChargeTry(const u8 *psn, u8 scode, u8 retry)
//{
//    u8 result = DET_CMD_FAIL;

//    while(retry--)
//	{
//	    result = EB_DetCharge(psn/*序列号*/, scode/*密码*/);
//		if(result == DET_CMD_SUCCESS)
//		{// 写延期指令执行成功
//		    return result;
//		}
//	}

//	return result;
//} /* EB_DetChargeTry */
//==================================================================================================
//| 函数名称 | EB_DetChargeTry 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 充电指令,带重试次数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-雷管序列码首址
//|          | scode-雷管密码
//|          | cmd_charge-充电指令代码
//|          | retry-重试次数
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------             
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetChargeTry(const u8 *psn, u8 scode, u8 cmd_charge, u8 retry)
{
    u8 result = DET_CMD_FAIL;

    while(retry--)
	{
	    result = EB_DetCharge(psn/*序列号*/, scode/*密码*/,cmd_charge);
		if(result == DET_CMD_SUCCESS)
		{// 写延期指令执行成功
		    return result;
		}
	}

	return result;
} /* EB_DetChargeTry */

//==================================================================================================
//| 函数名称 | EB_DetExpen 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 准备起爆指令 
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-雷管序列码首址
//|          | scode-雷管密码
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------             
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
//u8 EB_DetExpen(const u8 *psn, u8 scode)
//{
//    u8 cmd[5] = {EXPEN/* 充电指令 */, 0x00, 0x00, 0x00, 0x00};
//	u8 buf[1] = {0x00};	// 用于缓存同步头，实际没有数据
//	
//	cmd[1] = *psn;
//	cmd[2] = *(psn + 1);
//	cmd[3] = scode;
//	cmd[4] = cmd[1];
//	/* 发送 */
//	DetTransmit(cmd, sizeof(cmd));

//	/* 只接收同步头 */
//	if(DetReceiver(buf, 0) == EB_DET_TRANSCEIVER_SUCCESS)
//	{
//		return DET_CMD_SUCCESS;    //指令执行成功
//	}

//	return DET_CMD_FAIL;               //指令执行失败
//} /* EB_DetExpen */
//==================================================================================================
//| 函数名称 | EB_DetExpen 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 准备起爆指令 
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-雷管序列码首址
//|          | scode-雷管密码
//|          | cmd_expen-雷管准备起爆命令
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------             
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetExpen(const u8 *psn, u8 scode, u8 cmd_expen)
{
    u8 cmd[5] = {0x00, 0x00, 0x00, 0x00, 0x00};
	u8 buf[1] = {0x00};	// 用于缓存同步头，实际没有数据
	
	cmd[0] = cmd_expen;
	cmd[1] = *psn;
	cmd[2] = *(psn + 1);
	cmd[3] = scode;
	cmd[4] = cmd[1];
	
	OSSchedLock();//发送命令期间禁止切换任务,避免其他任务扶起当前任务
		
	/* 发送 */
	DetTransmit(cmd, sizeof(cmd));

	/* 只接收同步头 */
	if(DetReceiver(buf, 0) == EB_DET_TRANSCEIVER_SUCCESS)
	{
		OSSchedUnlock();//打开任务切换
		return DET_CMD_SUCCESS;    //指令执行成功
	}
	OSSchedUnlock();//打开任务切换
	return DET_CMD_FAIL;               //指令执行失败
} /* EB_DetExpen */

//==================================================================================================
//| 函数名称 | EB_DetExpenTry 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 准备起爆指令,带重试次数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-雷管序列码首址
//|          | scode-雷管密码
//|          | retry-重试次数
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------            
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
//u8 EB_DetExpenTry(const u8 *psn, u8 scode, u8 retry)
//{
//    u8 result = DET_CMD_FAIL;

//    while(retry--)
//	{
//	    result = EB_DetExpen(psn/*序列号*/, scode/*密码*/);
//		if(result == DET_CMD_SUCCESS)
//		{// 写延期指令执行成功
//		    return result;
//		}
//	}

//	return result;
//} /* EB_DetExpenTry */
//==================================================================================================
//| 函数名称 | EB_DetExpenTry 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 准备起爆指令,带重试次数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | psn-雷管序列码首址
//|          | scode-雷管密码
//|          | cmd_expen-雷管准备起爆命令
//|          | retry-重试次数
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | DET_CMD_SUCCESS-指令执行成功
//|          | DET_CMD_FAIL-指令执行失败 
//|----------|--------------------------------------------------------------------------------------            
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 EB_DetExpenTry(const u8 *psn, u8 scode, u8 cmd_expen, u8 retry)
{
    u8 result = DET_CMD_FAIL;

    while(retry--)
	{
	    result = EB_DetExpen(psn/*序列号*/, scode/*密码*/, cmd_expen/*准备起爆命令*/);
		if(result == DET_CMD_SUCCESS)
		{// 写延期指令执行成功
		    return result;
		}
	}

	return result;
} /* EB_DetExpenTry */
